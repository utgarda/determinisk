//! SP1 host orchestration for physics proof generation

use sp1_sdk::{include_elf, ProverClient, SP1Stdin};
use determinisk_core::{Scalar, Vec2};
use clap::Parser;

/// SP1 program ELF will be generated by build script  
const ELF: &[u8] = include_elf!("determinisk-sp1-program");

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Generate actual proof (otherwise just execute)
    #[arg(long)]
    prove: bool,
}

fn main() {
    // Parse command line arguments
    let args = Args::parse();
    
    // Load environment variables
    dotenv::dotenv().ok();
    
    // Setup logging
    sp1_sdk::utils::setup_logger();

    // Create prover client based on environment
    // This will use SP1_PROVER env var (mock, cpu, cuda, or network)
    let client = ProverClient::from_env();

    // Run multiple test scenarios
    println!("SP1 Physics Simulation");
    println!("======================\n");

    // Test 1: Ball dropped from height
    println!("Test 1: Ball dropped from height");
    run_simulation(
        &client,
        100,  // steps
        Vec2::new(100.0, 50.0),  // initial position
        Vec2::ZERO,              // initial velocity
        args.prove,
    );

    // Test 2: Horizontal projectile
    println!("\nTest 2: Horizontal projectile");
    run_simulation(
        &client,
        200,  // steps
        Vec2::new(10.0, 100.0),  // initial position
        Vec2::new(10.0, 0.0),    // initial velocity
        args.prove,
    );

    // Test 3: Angled launch
    println!("\nTest 3: Angled launch");
    run_simulation(
        &client,
        200,  // steps
        Vec2::new(10.0, 10.0),   // initial position
        Vec2::new(10.0, 15.0),   // initial velocity
        args.prove,
    );
    
    println!("\n✓ All simulations completed!");
    let mode = std::env::var("SP1_PROVER").unwrap_or_else(|_| "mock".to_string());
    if args.prove {
        println!("Generated proofs using SP1_PROVER={} mode", mode);
    } else {
        println!("Executed without proofs using SP1_PROVER={} mode", mode);
        println!("To generate proofs, run with --prove flag");
    }
}

fn run_simulation<P: sp1_prover::components::SP1ProverComponents>(
    client: &impl sp1_sdk::prover::Prover<P>,
    num_steps: u32,
    initial_pos: Vec2,
    initial_vel: Vec2,
    prove: bool,
) {
    // Prepare input
    let mut stdin = SP1Stdin::new();
    stdin.write(&num_steps);
    stdin.write(&Scalar::from_float(initial_pos.x.to_float()).to_bits());
    stdin.write(&Scalar::from_float(initial_pos.y.to_float()).to_bits());
    stdin.write(&Scalar::from_float(initial_vel.x.to_float()).to_bits());
    stdin.write(&Scalar::from_float(initial_vel.y.to_float()).to_bits());

    let start = std::time::Instant::now();
    
    if prove {
        // Generate actual proof
        println!("  Generating proof...");
        
        // First get the proving key
        let (pk, _) = client.setup(ELF);
        
        // Generate proof with the proving key
        let proof = client.prove(&pk, &stdin, sp1_sdk::SP1ProofMode::Core)
            .expect("Failed to generate proof");
        
        let elapsed = start.elapsed();

        // Extract public outputs from the proof
        let mut public_values = proof.public_values.clone();
        let final_x = public_values.read::<i32>();
        let final_y = public_values.read::<i32>();
        let final_vx = public_values.read::<i32>();
        let final_vy = public_values.read::<i32>();
        let steps = public_values.read::<u32>();

        println!("  Final position: ({:.2}, {:.2})",
            Scalar::from_bits(final_x).to_float(),
            Scalar::from_bits(final_y).to_float()
        );
        println!("  Final velocity: ({:.2}, {:.2})",
            Scalar::from_bits(final_vx).to_float(),
            Scalar::from_bits(final_vy).to_float()
        );
        println!("  Steps: {}", steps);
        println!("  Proof generation time: {:.2}s", elapsed.as_secs_f32());
        
        // Verify the proof
        println!("  Verifying proof...");
        client.verify(&proof, &pk.vk)
            .expect("Failed to verify proof");
        println!("  ✓ Proof verified successfully!");
        
    } else {
        // Just execute without proof
        println!("  Executing simulation...");
        let (mut public_values, report) = client.execute(ELF, &stdin)
            .expect("Failed to execute program");

        let elapsed = start.elapsed();

        // Extract public outputs
        let final_x = public_values.read::<i32>();
        let final_y = public_values.read::<i32>();
        let final_vx = public_values.read::<i32>();
        let final_vy = public_values.read::<i32>();
        let steps = public_values.read::<u32>();

        println!("  Final position: ({:.2}, {:.2})",
            Scalar::from_bits(final_x).to_float(),
            Scalar::from_bits(final_y).to_float()
        );
        println!("  Final velocity: ({:.2}, {:.2})",
            Scalar::from_bits(final_vx).to_float(),
            Scalar::from_bits(final_vy).to_float()
        );
        println!("  Steps: {}", steps);
        println!("  Execution time: {:.2}s", elapsed.as_secs_f32());
        println!("  Cycles: {}", report.total_instruction_count());
    }
}